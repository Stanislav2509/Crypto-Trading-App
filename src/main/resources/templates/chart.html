<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title th:text="'Candlestick Chart for ' + ${pair}">Chart</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>

</head>
<body>

<h2 th:text="${name} + ' ' + ${pair}"></h2>

<form method="get" th:action="@{/chart/{pair}(pair=${pair})}">
    <label for="interval">Избери интервал:</label>
    <select name="interval" id="interval">
        <option value="1" th:selected="${interval == 1}">1 минута</option>
        <option value="5" th:selected="${interval == 5}">5 минути</option>
        <option value="60" th:selected="${interval == 60}">1 час</option>
        <option value="1440" th:selected="${interval == 1440}">1 ден</option>
    </select>
    <button type="submit">Покажи</button>
</form>

<div id="chart" style="width: 100%; height: 500px;"></div>

<script th:inline="javascript">
    window.candleData = /*[[${candles}]]*/ [];
</script>

<script>
    const formattedData = candleData.map(c => ({
        time: c.time,
        open: c.open,
        high: c.high,
        low: c.low,
        close: c.close
    }));

    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: window.innerWidth * 0.95,
        height: 500,
        layout: {
            backgroundColor: '#fff',
            textColor: '#333',
        },
        grid: {
            vertLines: { color: '#eee' },
            horzLines: { color: '#eee' },
        },
        timeScale: {
            timeVisible: true,
            secondsVisible: false,
        },
    });

    const candleSeries = chart.addCandlestickSeries();
    candleSeries.setData(formattedData);

    setTimeout(() => {
        chart.resize(window.innerWidth * 0.95, 500);
    }, 100);
</script>

<div>
    <button type="button" onclick="showBuyForm()">Buy</button>
    <button type="button" onclick="showSellForm()">Sell</button>
</div>

<div id="buyForm" style="display: block;">
    <form method="post" th:action="@{/buy}" th:object="${tradeBindingModel}">
    <h2 th:text="'Buy ' + ${pair}"></h2>
    <input type="hidden" th:field="*{pair}" />

    <label>Spend USD </label>
    <input type="number" th:field="*{spend}" step="0.01" min="0" th:attr="max=${userBalance}"
           oninput="validateSpendUsd()" id="spendUsd" name="spend" required />
    <button type="button" onclick="setMaxUsd()">MAX</button>
    <br/>

    <label th:text="'Receive ' + ${pair}"></label>
    <input type="text" id="receiveCrypto" name="receive" readonly />

    <br/>
    <button type="submit">Buy</button>
    </form>
</div>

<div id="sellForm" style="display: none;">
    <form method="post" th:action="@{/sell}" th:object = "${tradeBindingModel}">
    <h2 th:text="'Sell ' + ${pair}"></h2>
    <input type="hidden" th:field="*{pair}" />

    <label  th:text="'Spend ' + ${pair}"></label>
    <input type="number" th:field="*{spend}" step="any" min="0" th:attr="max=${quantityCrypto}"
           oninput="validateSpendCrypto()" id="spendCrypto" name="spend"  required />
    <button type="button" onclick="setMaxCrypto()">MAX</button>
    <small th:if="${#fields.hasErrors('spend')}"
           th:errors="*{spend}" ></small>
    <br/>

    <label >Receive USD </label>
    <input type="text" id="receiveUsd" name="receive" readonly />

    <br/>
    <button type="submit">Sell</button>
    </form>
</div>

<script>
    function showBuyForm() {
        document.getElementById("buyForm").style.display = "block";
        document.getElementById("sellForm").style.display = "none";
    }

    function showSellForm() {
        document.getElementById("sellForm").style.display = "block";
        document.getElementById("buyForm").style.display = "none";
    }
</script>

<script>
    const currentPrice = [[${currentPrice}]];
    const userBalance = [[${userBalance}]];
    const quantityCrypto = [[${quantityCrypto}]];

    function validateSpendUsd() {
        const spendInput = document.getElementById("spendUsd");
        const max = parseFloat(spendInput.max);
        const value = parseFloat(spendInput.value);

        if (value > max) {
            spendInput.value = max;
        }

        calculateReceiveCrypto();
    }

    function setMaxUsd() {
         document.getElementById("spendUsd").value = userBalance;
        calculateReceiveCrypto();
    }
        document.getElementById("spendUsd").addEventListener("input", calculateReceiveCrypto);

    function calculateReceiveCrypto() {
       const spend = parseFloat(document.getElementById("spendUsd").value);
        const receive = spend / currentPrice;
        document.getElementById("receiveCrypto").value = isNaN(receive) ? '' : receive.toFixed(6);
    }

function validateSpendCrypto() {
        const spendInput = document.getElementById("spendCrypto");
        const max = parseFloat(spendInput.max);
        const value = parseFloat(spendInput.value);

        if (value > max) {
            spendInput.value = max;
        }

        calculateReceiveUsd();
    }

    function setMaxCrypto() {
        document.getElementById("spendCrypto").value = quantityCrypto;
        calculateReceiveUsd();
    }
        document.getElementById("spendCrypto").addEventListener("input", calculateReceiveUsd);

    function calculateReceiveUsd() {
       const spend = parseFloat(document.getElementById("spendCrypto").value);
        const receive = spend * currentPrice;
        document.getElementById("receiveUsd").value = isNaN(receive) ? '' : receive.toFixed(6);
    }
</script>

</body>
</html>
